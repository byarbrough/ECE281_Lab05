ECE281_Lab05
============

More PRISM!

| File Name | Description |
------------|------------
Nexys2_top _shell.vhd | Top level file, interacts with board
PRISM.vhd | Interaction between PRISM code and Nexys2
Part2_PRISM.psm | PRISM code for the second part of the project: the counter
RAM_bug.PNG | Screenshot of VHDL error
ROM_176x4.vhd | Original ROM file
ROM_176x4 _Count.vhd | ROM for part2
ROM_176x4 _Toggle.vhd | ROM for the creative segment
part2_counter.bit | Bit file for Part 2
part1_bit | Bit file for part 1
sim_0 _to _ 165ns.PNG | Screenshot of Part 1 running testbench
state_diagram.PNG | State Diagram for PRISM. From Manual.
toggleCount.bit | Bit file for creative segment
toggle_counter _PRISM.psm | PRISM file for creative segment



##Part 1

###Testbench - The Initial Program

Here is the initial testbench simulation:

![alt text](https://github.com/byarbrough/ECE281_Lab05/blob/master/sim_0_to_165ns.PNG?raw=true "PRISM Testbench")

As you can see, there are a lot of signals in there. Each segment is labled in accordance with this state diagram:

![alt text](https://github.com/byarbrough/ECE281_Lab05/blob/master/state_diagram.PNG?raw=true "PRISM State Diagram")

Figuring out what this prgram does really wasn't incredibly difficult. It starts with _irld_ high, which signals a fetch (the program has to begin with a fetch). Once PRISM has fetched the incoming instruction it needs to decode whatever was just on the data bus, and is now on the instruction register. Depending on which instruction it is (ROT, ADDI, LDAI, ect.) the state diagram progresses accordingly. The important thing to note is that it always returns to _Fetch_ and then _Decode_ after every execution.

####The Big Picture
So what does this program do? Big picture, it starts at '9' and then coutns up by '1' over and over, continuously outputting the sum to port 3.

Step by step:
1. LDAI: Load '8' into the accumulator
2. ADDI: Add '1' to the accumulator
3. OUT: Display the result on Port 3
4. JN: Jump to "02"
5. At this point the program repeats from Step 2

###Controller State Walkthrough


#### When I wired everything up to the topshell, Part 1 worked as expected. HUZZAH!

##Part 2

####This was a little more of a hassel

##Questions

1.	When the controller’s current state is “FETCH,” what is the status of the following control lines:

    a. PCLd - HIGH
    
    b. IRLd - HIGH
    
    c. ACCLd - LOW

2.	The current state is Decode LoAddr and the IR contains “OUT.”  What are the control signals are asserted, and what will the next state be?

    a. marlold - HIGH
    b. pcld - HIGH
    c. r_w - HIGH
    d. iosel_l - HIGH
    e. All others LOW
    
    The next state will be _Direct IO Execute_

3.	What are the three status signals sent from the PRISM datapath to the PRISM controller?

    I'm not really sure. By the diagram below there are only two outputs from Datapath, Reset and Clock, which are inputs to the controller. These aren't really status signals either...

4.	Why is it important that ACCLd signal be active during the execute state for the ADDI instruction?

    Becuase ADDI adds the operand to the number in the accumulator, ACCLd must be high so that the accumulator can update.

5.	What changes are necessary to the PRISM datapath to add another instruction (SUBI, which would subtract an immediate value from the accumulator) to the instruction set?

    It depends on how that was done. If it was to be an independent instruction than one of the instructions would have to be removed or a MUX with another line would have to be used to overcome the 16 instruction limit. This would then cause problems because _Fetch_ would have to get more bits. It really isn't a very easy change; it is typically better to just use "NEG" and manipulate memory or do the Two's Compliment by hand.

